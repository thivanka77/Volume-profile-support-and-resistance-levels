//@version=6
indicator("Volume Profile + SMC levels", shorttitle="VP SMC", overlay=true, max_bars_back=5000, max_lines_count=500)

//────────────────────────────────────────────
// INPUTS (inline format)
//────────────────────────────────────────────
vp_use_visible_range   = input.bool(false, "Use Visible Range", group="Lookback Period", tooltip="Calculate Volume Profile using all visible bars in the current chart")
vp_lookback_depth      = input.int(200, "Fixed Range Lookback Depth [10-3000]", minval=10, maxval=3000, group="Lookback Period", tooltip="Number of historical bars to include in the calculation. Ignored if 'Use Visible Range' is enabled")

vp_num_bars            = input.int(200, "Number of Volume Bars [10-490]", minval=10, maxval=490, group="Volume Bars", tooltip="Number of Volume Profile bars")
vp_bar_thickness       = input.int(1, "Volume Bar Thickness [1-30]", minval=1, maxval=30, group="Volume Bars", tooltip="Width of each volume bar in the Volume Profile")
vp_bar_len_mult        = input.int(20, "Bar Length Multiplier [1-50]", minval=1, maxval=50, group="Volume Bars", tooltip="Volume Profile Bar length multiplier")
vp_right_offset        = input.int(70, "Right Offset [0-400]", minval=0, maxval=400, group="Volume Bars", tooltip="Space between the right bar of the chart and the Volume Profile")
vp_volume_type         = input.string("Both", "Volume Type", options=["Both","Bullish","Bearish"], group="Volume Bars", tooltip="Select the type of Volume to include")
vp_bar_color           = input.color(color.new(color.gray,50), "Volume Bar Color", group="Volume Bars", tooltip="Color of the volume bars in the Volume Profile")

vp_display_poc         = input.bool(true, "Display Point of Control (PoC)", group="Point of Control", tooltip="Enable or disable the display of the Point of Control (PoC)")
vp_poc_line_thickness  = input.int(1, "PoC Line Thickness [1-30]", minval=1, maxval=30, group="Point of Control", tooltip="Width of the PoC line")
vp_poc_line_color      = input.color(color.red, "PoC Line Color", group="Point of Control", tooltip="Color of the Point of Control (PoC) line")

vp_display_va          = input.bool(true, "Display Value Area", group="Value Area", tooltip="Enable or disable the display of the Value Area")
vp_va_percent          = input.int(68, "Value Area Percentage (%) [5-95]", minval=5, maxval=95, group="Value Area", tooltip="Percentage of the Value Area")
vp_va_bar_color        = input.color(color.blue, "Value Area Bar Color", group="Value Area", tooltip="Color of the volume bars in the Value Area")
vp_display_va_lines    = input.bool(true, "Display Value Area Lines", group="Value Area", tooltip="Enable or disable the display of the Value Area lines. Ignored if 'Display Value Area' is disabled")
vp_va_lines_thickness  = input.int(1, "Value Area Lines Thickness [1-20]", minval=1, maxval=20, group="Value Area", tooltip="Width of the Value Area lines")

// Support/Resistance inputs
swing_sensitivity = input.int(3, "Swing Sensitivity (bars)", minval=1, maxval=20, group="Support/Resistance", tooltip="Bars on each side to confirm pivot")
lvn_sensitivity   = input.float(0.5, "LVN Sensitivity (%)", minval=0.1, maxval=5, group="Support/Resistance", tooltip="Minimum % dip vs neighbors to qualify as LVN")
sr_num_zones      = input.int(2, "Number of SR Zones", minval=1, maxval=10, group="Support/Resistance", tooltip="Max number of zones to keep on chart")
sr_zone_color     = input.color(color.new(color.green, 80), "SR Zone Color", group="Support/Resistance")
sr_zone_width     = input.float(0.3, "Zone Width (%)", minval=0.1, maxval=2, group="Support/Resistance")

//────────────────────────────────────────────
// VARIABLES
//────────────────────────────────────────────
var line poc = na
var line vah = na
var line val = na
var array<line> bars = array.new_line()
var array<float> volumes = array.new_float(vp_num_bars, 0)
var array<box> sr_boxes = array.new_box()

var int timeframe_minutes = 1000 * timeframe.in_seconds()
var int lookback_bars = vp_use_visible_range ? math.round((last_bar_time - chart.left_visible_bar_time) / timeframe_minutes) : vp_lookback_depth

float highest_price = ta.highest(lookback_bars)
float lowest_price  = ta.lowest(lookback_bars)
float price_interval= (highest_price - lowest_price) / (vp_num_bars - 1)

//────────────────────────────────────────────
// FUNCTIONS
//────────────────────────────────────────────
scale_volume(vol, max) =>
    float d = max / lookback_bars / (vp_bar_len_mult / 100)
    math.round(vol / d)

calculate_vp() =>
    // Ensure volumes array matches current bin count
    if array.size(volumes) != vp_num_bars
        array.clear(volumes)
        for _ = 0 to vp_num_bars - 1
            array.push(volumes, 0.0)
    else
        array.fill(volumes, 0)

    for i = 0 to lookback_bars - 1
        for j = 0 to vp_num_bars - 1
            float price_level = lowest_price + price_interval * j
            bool is_bullish   = close[i] >= open[i]
            bool include_vol  = vp_volume_type == "Both" ? true : (vp_volume_type == "Bullish" ? is_bullish : not is_bullish)
            if price_level >= low[i] and price_level < high[i] and include_vol
                array.set(volumes, j, volumes.get(j) + volume[i])

calculate_va(max_idx, max_vol) =>
    float sum_vol = volumes.sum()
    float va_vol  = sum_vol * vp_va_percent / 100
    int va_up     = max_idx
    int va_dn     = max_idx
    float va_sum  = max_vol
    while va_sum < va_vol
        float v_up = (va_up < vp_num_bars - 1) ? volumes.get(va_up + 1) : 0.0
        float v_dn = (va_dn > 0) ? volumes.get(va_dn - 1) : 0.0
        if v_up == 0 and v_dn == 0
            break
        if v_up >= v_dn
            va_sum += v_up
            va_up  += 1
        else
            va_sum += v_dn
            va_dn  -= 1
    [va_dn, va_up]

draw() =>
    // Ensure bars array has enough line handles
    if array.size(bars) < vp_num_bars
        for _ = array.size(bars) to vp_num_bars - 1
            array.push(bars, line.new(bar_index, close, bar_index, close, width=vp_bar_thickness))

    float max_vol = volumes.max()
    int max_idx   = volumes.indexof(max_vol)
    int x2        = bar_index + vp_right_offset

    // Draw bars
    for i = 0 to vp_num_bars - 1
        int vol   = scale_volume(volumes.get(i), max_vol)
        int x1    = x2 - vol
        float y   = lowest_price + price_interval * i
        line.set_xy1(bars.get(i), x1, y)
        line.set_xy2(bars.get(i), x2, y)
        line.set_color(bars.get(i), max_idx == i ? vp_poc_line_color : vp_bar_color)
        line.set_width(bars.get(i), vp_bar_thickness)

    // Draw PoC
    if vp_display_poc
        int vol   = scale_volume(max_vol, max_vol)
        int poc_x1= bar_index - lookback_bars
        int poc_x2= x2 - vol - 10
        float y   = lowest_price + price_interval * max_idx
        line.set_xy1(poc, poc_x1, y)
        line.set_xy2(poc, poc_x2, y)
        line.set_color(poc, vp_poc_line_color)
        line.set_width(poc, vp_poc_line_thickness)

    // Draw Value Area
    if vp_display_va
        [va_dn, va_up] = calculate_va(max_idx, max_vol)
        for i = va_dn to va_up
            if i != max_idx
                line.set_color(bars.get(i), vp_va_bar_color)
        if vp_display_va_lines
            int vah_vol = scale_volume(volumes.get(va_up), max_vol)
            int val_vol = scale_volume(volumes.get(va_dn), max_vol)
            int va_x1   = bar_index - lookback_bars
            int vah_x2  = x2 - vah_vol - 10
            int val_x2  = x2 - val_vol - 10
            float vah_y = lowest_price + price_interval * va_up
            float val_y = lowest_price + price_interval * va_dn
            line.set_xy1(vah, va_x1, vah_y)
            line.set_xy2(vah, vah_x2, vah_y)
            line.set_xy1(val, va_x1, val_y)
            line.set_xy2(val, val_x2, val_y)
            line.set_color(vah, vp_va_bar_color)
            line.set_color(val, vp_va_bar_color)
            line.set_width(vah, vp_va_lines_thickness)
            line.set_width(val, vp_va_lines_thickness)

// Map price to volume bin safely
price_to_bin(p) =>
    idx = int(math.round((p - lowest_price) / price_interval))
    idx := math.max(0, idx)
    idx := math.min(vp_num_bars - 1, idx)
    idx

// LVN check
is_lvn(idx, sens_perc) =>
    (idx > 0 and idx < vp_num_bars - 1) and
     (volumes.get(idx) < volumes.get(idx - 1) * (1 - sens_perc / 100) and
      volumes.get(idx) < volumes.get(idx + 1) * (1 - sens_perc / 100))

//────────────────────────────────────────────
// SUPPORT/RESISTANCE ZONES
//────────────────────────────────────────────
draw_sr_zones() =>
    // Confirmed pivots
    pivotLowVal  = ta.pivotlow(low,  swing_sensitivity, swing_sensitivity)
    pivotHighVal = ta.pivothigh(high, swing_sensitivity, swing_sensitivity)

    // Support from pivot low
    if not na(pivotLowVal)
        swing_price = pivotLowVal
        idx = price_to_bin(swing_price)
        if is_lvn(idx, lvn_sensitivity)
            zone_half = swing_price * sr_zone_width / 100
            y1 = swing_price - zone_half
            y2 = swing_price + zone_half
            x1 = bar_index - lookback_bars
            x2 = bar_index + vp_right_offset
            b  = box.new(x1, y1, x2, y2, bgcolor=sr_zone_color, border_color=sr_zone_color)
            array.push(sr_boxes, b)

    // Resistance from pivot high
    if not na(pivotHighVal)
        swing_price_h = pivotHighVal
        idx_h = price_to_bin(swing_price_h)
        if is_lvn(idx_h, lvn_sensitivity)
            zone_half_h = swing_price_h * sr_zone_width / 100
            yh1 = swing_price_h - zone_half_h
            yh2 = swing_price_h + zone_half_h
            x1h = bar_index - lookback_bars
            x2h = bar_index + vp_right_offset
            bh  = box.new(x1h, yh1, x2h, yh2, bgcolor=sr_zone_color, border_color=sr_zone_color)
            array.push(sr_boxes, bh)

    /// Keep only most recent zones (guard against empty array)
excess = array.size(sr_boxes) - sr_num_zones
if excess > 0
    for _ = 0 to excess - 1
        if array.size(sr_boxes) > 0
            box.delete(array.shift(sr_boxes))


//────────────────────────────────────────────
// INITIALIZATION + EXECUTION
//────────────────────────────────────────────
if barstate.isfirst
    for i = 0 to vp_num_bars - 1
        array.push(bars, line.new(bar_index, close, bar_index, close, width=vp_bar_thickness))
    if vp_display_poc
        poc := line.new(bar_index, close, bar_index, close, color=vp_poc_line_color, width=vp_poc_line_thickness)
    if vp_display_va and vp_display_va_lines
        vah := line.new(bar_index, close, bar_index, close, color=vp_va_bar_color, width=vp_va_lines_thickness)
        val := line.new(bar_index, close, bar_index, close, color=vp_va_bar_color, width=vp_va_lines_thickness)

// Always calculate and draw on each bar
calculate_vp()
draw()
draw_sr_zones()
